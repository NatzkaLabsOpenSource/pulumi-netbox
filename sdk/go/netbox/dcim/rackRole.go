// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dcim

import (
	"context"
	"reflect"

	"errors"
	"github.com/NatzkaLabsOpenSource/pulumi-netbox/sdk/go/netbox/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// From the [official documentation](https://docs.netbox.dev/en/stable/models/dcim/rackrole/):
//
// > Each rack can optionally be assigned a user-defined functional role. For example, you might designate a rack for compute or storage resources, or to house colocated customer devices.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/NatzkaLabsOpenSource/pulumi-netbox/sdk/go/netbox/dcim"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dcim.NewRackRole(ctx, "test", &dcim.RackRoleArgs{
//				Name:     pulumi.String("test"),
//				ColorHex: pulumi.String("111111"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type RackRole struct {
	pulumi.CustomResourceState

	ColorHex    pulumi.StringOutput      `pulumi:"colorHex"`
	Description pulumi.StringPtrOutput   `pulumi:"description"`
	Name        pulumi.StringOutput      `pulumi:"name"`
	Slug        pulumi.StringOutput      `pulumi:"slug"`
	Tags        pulumi.StringArrayOutput `pulumi:"tags"`
	TagsAlls    pulumi.StringArrayOutput `pulumi:"tagsAlls"`
}

// NewRackRole registers a new resource with the given unique name, arguments, and options.
func NewRackRole(ctx *pulumi.Context,
	name string, args *RackRoleArgs, opts ...pulumi.ResourceOption) (*RackRole, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ColorHex == nil {
		return nil, errors.New("invalid value for required argument 'ColorHex'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RackRole
	err := ctx.RegisterResource("netbox:dcim/rackRole:RackRole", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRackRole gets an existing RackRole resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRackRole(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RackRoleState, opts ...pulumi.ResourceOption) (*RackRole, error) {
	var resource RackRole
	err := ctx.ReadResource("netbox:dcim/rackRole:RackRole", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RackRole resources.
type rackRoleState struct {
	ColorHex    *string  `pulumi:"colorHex"`
	Description *string  `pulumi:"description"`
	Name        *string  `pulumi:"name"`
	Slug        *string  `pulumi:"slug"`
	Tags        []string `pulumi:"tags"`
	TagsAlls    []string `pulumi:"tagsAlls"`
}

type RackRoleState struct {
	ColorHex    pulumi.StringPtrInput
	Description pulumi.StringPtrInput
	Name        pulumi.StringPtrInput
	Slug        pulumi.StringPtrInput
	Tags        pulumi.StringArrayInput
	TagsAlls    pulumi.StringArrayInput
}

func (RackRoleState) ElementType() reflect.Type {
	return reflect.TypeOf((*rackRoleState)(nil)).Elem()
}

type rackRoleArgs struct {
	ColorHex    string   `pulumi:"colorHex"`
	Description *string  `pulumi:"description"`
	Name        *string  `pulumi:"name"`
	Slug        *string  `pulumi:"slug"`
	Tags        []string `pulumi:"tags"`
}

// The set of arguments for constructing a RackRole resource.
type RackRoleArgs struct {
	ColorHex    pulumi.StringInput
	Description pulumi.StringPtrInput
	Name        pulumi.StringPtrInput
	Slug        pulumi.StringPtrInput
	Tags        pulumi.StringArrayInput
}

func (RackRoleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rackRoleArgs)(nil)).Elem()
}

type RackRoleInput interface {
	pulumi.Input

	ToRackRoleOutput() RackRoleOutput
	ToRackRoleOutputWithContext(ctx context.Context) RackRoleOutput
}

func (*RackRole) ElementType() reflect.Type {
	return reflect.TypeOf((**RackRole)(nil)).Elem()
}

func (i *RackRole) ToRackRoleOutput() RackRoleOutput {
	return i.ToRackRoleOutputWithContext(context.Background())
}

func (i *RackRole) ToRackRoleOutputWithContext(ctx context.Context) RackRoleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RackRoleOutput)
}

// RackRoleArrayInput is an input type that accepts RackRoleArray and RackRoleArrayOutput values.
// You can construct a concrete instance of `RackRoleArrayInput` via:
//
//	RackRoleArray{ RackRoleArgs{...} }
type RackRoleArrayInput interface {
	pulumi.Input

	ToRackRoleArrayOutput() RackRoleArrayOutput
	ToRackRoleArrayOutputWithContext(context.Context) RackRoleArrayOutput
}

type RackRoleArray []RackRoleInput

func (RackRoleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RackRole)(nil)).Elem()
}

func (i RackRoleArray) ToRackRoleArrayOutput() RackRoleArrayOutput {
	return i.ToRackRoleArrayOutputWithContext(context.Background())
}

func (i RackRoleArray) ToRackRoleArrayOutputWithContext(ctx context.Context) RackRoleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RackRoleArrayOutput)
}

// RackRoleMapInput is an input type that accepts RackRoleMap and RackRoleMapOutput values.
// You can construct a concrete instance of `RackRoleMapInput` via:
//
//	RackRoleMap{ "key": RackRoleArgs{...} }
type RackRoleMapInput interface {
	pulumi.Input

	ToRackRoleMapOutput() RackRoleMapOutput
	ToRackRoleMapOutputWithContext(context.Context) RackRoleMapOutput
}

type RackRoleMap map[string]RackRoleInput

func (RackRoleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RackRole)(nil)).Elem()
}

func (i RackRoleMap) ToRackRoleMapOutput() RackRoleMapOutput {
	return i.ToRackRoleMapOutputWithContext(context.Background())
}

func (i RackRoleMap) ToRackRoleMapOutputWithContext(ctx context.Context) RackRoleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RackRoleMapOutput)
}

type RackRoleOutput struct{ *pulumi.OutputState }

func (RackRoleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RackRole)(nil)).Elem()
}

func (o RackRoleOutput) ToRackRoleOutput() RackRoleOutput {
	return o
}

func (o RackRoleOutput) ToRackRoleOutputWithContext(ctx context.Context) RackRoleOutput {
	return o
}

func (o RackRoleOutput) ColorHex() pulumi.StringOutput {
	return o.ApplyT(func(v *RackRole) pulumi.StringOutput { return v.ColorHex }).(pulumi.StringOutput)
}

func (o RackRoleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RackRole) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o RackRoleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *RackRole) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o RackRoleOutput) Slug() pulumi.StringOutput {
	return o.ApplyT(func(v *RackRole) pulumi.StringOutput { return v.Slug }).(pulumi.StringOutput)
}

func (o RackRoleOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RackRole) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

func (o RackRoleOutput) TagsAlls() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RackRole) pulumi.StringArrayOutput { return v.TagsAlls }).(pulumi.StringArrayOutput)
}

type RackRoleArrayOutput struct{ *pulumi.OutputState }

func (RackRoleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RackRole)(nil)).Elem()
}

func (o RackRoleArrayOutput) ToRackRoleArrayOutput() RackRoleArrayOutput {
	return o
}

func (o RackRoleArrayOutput) ToRackRoleArrayOutputWithContext(ctx context.Context) RackRoleArrayOutput {
	return o
}

func (o RackRoleArrayOutput) Index(i pulumi.IntInput) RackRoleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RackRole {
		return vs[0].([]*RackRole)[vs[1].(int)]
	}).(RackRoleOutput)
}

type RackRoleMapOutput struct{ *pulumi.OutputState }

func (RackRoleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RackRole)(nil)).Elem()
}

func (o RackRoleMapOutput) ToRackRoleMapOutput() RackRoleMapOutput {
	return o
}

func (o RackRoleMapOutput) ToRackRoleMapOutputWithContext(ctx context.Context) RackRoleMapOutput {
	return o
}

func (o RackRoleMapOutput) MapIndex(k pulumi.StringInput) RackRoleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RackRole {
		return vs[0].(map[string]*RackRole)[vs[1].(string)]
	}).(RackRoleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RackRoleInput)(nil)).Elem(), &RackRole{})
	pulumi.RegisterInputType(reflect.TypeOf((*RackRoleArrayInput)(nil)).Elem(), RackRoleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RackRoleMapInput)(nil)).Elem(), RackRoleMap{})
	pulumi.RegisterOutputType(RackRoleOutput{})
	pulumi.RegisterOutputType(RackRoleArrayOutput{})
	pulumi.RegisterOutputType(RackRoleMapOutput{})
}
