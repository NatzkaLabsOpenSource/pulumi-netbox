// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dcim

import (
	"context"
	"reflect"

	"github.com/NatzkaLabsOpenSource/pulumi-netbox/sdk/go/netbox/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// From the [official documentation](https://docs.netbox.dev/en/stable/features/devices-cabling/#virtual-chassis):
//
//	> Sometimes it is necessary to model a set of physical devices as sharing a single management plane. Perhaps the most common example of such a scenario is stackable switches. These can be modeled as virtual chassis in NetBox, with one device acting as the chassis master and the rest as members. All components of member devices will appear on the master.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/NatzkaLabsOpenSource/pulumi-netbox/sdk/go/netbox/dcim"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dcim.NewVirtualChassis(ctx, "example", &dcim.VirtualChassisArgs{
//				Description: pulumi.String("virtual chassis"),
//				Domain:      pulumi.String("domain"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type VirtualChassis struct {
	pulumi.CustomResourceState

	Comments     pulumi.StringPtrOutput   `pulumi:"comments"`
	CustomFields pulumi.StringMapOutput   `pulumi:"customFields"`
	Description  pulumi.StringPtrOutput   `pulumi:"description"`
	Domain       pulumi.StringPtrOutput   `pulumi:"domain"`
	Name         pulumi.StringOutput      `pulumi:"name"`
	Tags         pulumi.StringArrayOutput `pulumi:"tags"`
}

// NewVirtualChassis registers a new resource with the given unique name, arguments, and options.
func NewVirtualChassis(ctx *pulumi.Context,
	name string, args *VirtualChassisArgs, opts ...pulumi.ResourceOption) (*VirtualChassis, error) {
	if args == nil {
		args = &VirtualChassisArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource VirtualChassis
	err := ctx.RegisterResource("netbox:dcim/virtualChassis:VirtualChassis", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVirtualChassis gets an existing VirtualChassis resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVirtualChassis(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VirtualChassisState, opts ...pulumi.ResourceOption) (*VirtualChassis, error) {
	var resource VirtualChassis
	err := ctx.ReadResource("netbox:dcim/virtualChassis:VirtualChassis", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VirtualChassis resources.
type virtualChassisState struct {
	Comments     *string           `pulumi:"comments"`
	CustomFields map[string]string `pulumi:"customFields"`
	Description  *string           `pulumi:"description"`
	Domain       *string           `pulumi:"domain"`
	Name         *string           `pulumi:"name"`
	Tags         []string          `pulumi:"tags"`
}

type VirtualChassisState struct {
	Comments     pulumi.StringPtrInput
	CustomFields pulumi.StringMapInput
	Description  pulumi.StringPtrInput
	Domain       pulumi.StringPtrInput
	Name         pulumi.StringPtrInput
	Tags         pulumi.StringArrayInput
}

func (VirtualChassisState) ElementType() reflect.Type {
	return reflect.TypeOf((*virtualChassisState)(nil)).Elem()
}

type virtualChassisArgs struct {
	Comments     *string           `pulumi:"comments"`
	CustomFields map[string]string `pulumi:"customFields"`
	Description  *string           `pulumi:"description"`
	Domain       *string           `pulumi:"domain"`
	Name         *string           `pulumi:"name"`
	Tags         []string          `pulumi:"tags"`
}

// The set of arguments for constructing a VirtualChassis resource.
type VirtualChassisArgs struct {
	Comments     pulumi.StringPtrInput
	CustomFields pulumi.StringMapInput
	Description  pulumi.StringPtrInput
	Domain       pulumi.StringPtrInput
	Name         pulumi.StringPtrInput
	Tags         pulumi.StringArrayInput
}

func (VirtualChassisArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*virtualChassisArgs)(nil)).Elem()
}

type VirtualChassisInput interface {
	pulumi.Input

	ToVirtualChassisOutput() VirtualChassisOutput
	ToVirtualChassisOutputWithContext(ctx context.Context) VirtualChassisOutput
}

func (*VirtualChassis) ElementType() reflect.Type {
	return reflect.TypeOf((**VirtualChassis)(nil)).Elem()
}

func (i *VirtualChassis) ToVirtualChassisOutput() VirtualChassisOutput {
	return i.ToVirtualChassisOutputWithContext(context.Background())
}

func (i *VirtualChassis) ToVirtualChassisOutputWithContext(ctx context.Context) VirtualChassisOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VirtualChassisOutput)
}

// VirtualChassisArrayInput is an input type that accepts VirtualChassisArray and VirtualChassisArrayOutput values.
// You can construct a concrete instance of `VirtualChassisArrayInput` via:
//
//	VirtualChassisArray{ VirtualChassisArgs{...} }
type VirtualChassisArrayInput interface {
	pulumi.Input

	ToVirtualChassisArrayOutput() VirtualChassisArrayOutput
	ToVirtualChassisArrayOutputWithContext(context.Context) VirtualChassisArrayOutput
}

type VirtualChassisArray []VirtualChassisInput

func (VirtualChassisArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VirtualChassis)(nil)).Elem()
}

func (i VirtualChassisArray) ToVirtualChassisArrayOutput() VirtualChassisArrayOutput {
	return i.ToVirtualChassisArrayOutputWithContext(context.Background())
}

func (i VirtualChassisArray) ToVirtualChassisArrayOutputWithContext(ctx context.Context) VirtualChassisArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VirtualChassisArrayOutput)
}

// VirtualChassisMapInput is an input type that accepts VirtualChassisMap and VirtualChassisMapOutput values.
// You can construct a concrete instance of `VirtualChassisMapInput` via:
//
//	VirtualChassisMap{ "key": VirtualChassisArgs{...} }
type VirtualChassisMapInput interface {
	pulumi.Input

	ToVirtualChassisMapOutput() VirtualChassisMapOutput
	ToVirtualChassisMapOutputWithContext(context.Context) VirtualChassisMapOutput
}

type VirtualChassisMap map[string]VirtualChassisInput

func (VirtualChassisMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VirtualChassis)(nil)).Elem()
}

func (i VirtualChassisMap) ToVirtualChassisMapOutput() VirtualChassisMapOutput {
	return i.ToVirtualChassisMapOutputWithContext(context.Background())
}

func (i VirtualChassisMap) ToVirtualChassisMapOutputWithContext(ctx context.Context) VirtualChassisMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VirtualChassisMapOutput)
}

type VirtualChassisOutput struct{ *pulumi.OutputState }

func (VirtualChassisOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VirtualChassis)(nil)).Elem()
}

func (o VirtualChassisOutput) ToVirtualChassisOutput() VirtualChassisOutput {
	return o
}

func (o VirtualChassisOutput) ToVirtualChassisOutputWithContext(ctx context.Context) VirtualChassisOutput {
	return o
}

func (o VirtualChassisOutput) Comments() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VirtualChassis) pulumi.StringPtrOutput { return v.Comments }).(pulumi.StringPtrOutput)
}

func (o VirtualChassisOutput) CustomFields() pulumi.StringMapOutput {
	return o.ApplyT(func(v *VirtualChassis) pulumi.StringMapOutput { return v.CustomFields }).(pulumi.StringMapOutput)
}

func (o VirtualChassisOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VirtualChassis) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o VirtualChassisOutput) Domain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VirtualChassis) pulumi.StringPtrOutput { return v.Domain }).(pulumi.StringPtrOutput)
}

func (o VirtualChassisOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *VirtualChassis) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o VirtualChassisOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VirtualChassis) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

type VirtualChassisArrayOutput struct{ *pulumi.OutputState }

func (VirtualChassisArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VirtualChassis)(nil)).Elem()
}

func (o VirtualChassisArrayOutput) ToVirtualChassisArrayOutput() VirtualChassisArrayOutput {
	return o
}

func (o VirtualChassisArrayOutput) ToVirtualChassisArrayOutputWithContext(ctx context.Context) VirtualChassisArrayOutput {
	return o
}

func (o VirtualChassisArrayOutput) Index(i pulumi.IntInput) VirtualChassisOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VirtualChassis {
		return vs[0].([]*VirtualChassis)[vs[1].(int)]
	}).(VirtualChassisOutput)
}

type VirtualChassisMapOutput struct{ *pulumi.OutputState }

func (VirtualChassisMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VirtualChassis)(nil)).Elem()
}

func (o VirtualChassisMapOutput) ToVirtualChassisMapOutput() VirtualChassisMapOutput {
	return o
}

func (o VirtualChassisMapOutput) ToVirtualChassisMapOutputWithContext(ctx context.Context) VirtualChassisMapOutput {
	return o
}

func (o VirtualChassisMapOutput) MapIndex(k pulumi.StringInput) VirtualChassisOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VirtualChassis {
		return vs[0].(map[string]*VirtualChassis)[vs[1].(string)]
	}).(VirtualChassisOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VirtualChassisInput)(nil)).Elem(), &VirtualChassis{})
	pulumi.RegisterInputType(reflect.TypeOf((*VirtualChassisArrayInput)(nil)).Elem(), VirtualChassisArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VirtualChassisMapInput)(nil)).Elem(), VirtualChassisMap{})
	pulumi.RegisterOutputType(VirtualChassisOutput{})
	pulumi.RegisterOutputType(VirtualChassisArrayOutput{})
	pulumi.RegisterOutputType(VirtualChassisMapOutput{})
}
