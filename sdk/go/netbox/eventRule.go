// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package netbox

import (
	"context"
	"reflect"

	"errors"
	"github.com/NatzkaLabsOpenSource/pulumi-netbox/sdk/go/netbox/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// From the [official documentation](https://docs.netbox.dev/en/stable/features/event-rules/):
//
// > NetBox can be configured via Event Rules to transmit outgoing webhooks to remote systems in response to internal object changes. The receiver can act on the data in these webhook messages to perform related tasks.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/NatzkaLabsOpenSource/pulumi-netbox/sdk/go/netbox"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			test, err := netbox.NewWebhook(ctx, "test", &netbox.WebhookArgs{
//				Name:       pulumi.String("my-webhook"),
//				PayloadUrl: pulumi.String("https://example.com/webhook"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = netbox.NewEventRule(ctx, "test", &netbox.EventRuleArgs{
//				Name: pulumi.String("my-event-rule"),
//				ContentTypes: pulumi.StringArray{
//					pulumi.String("dcim.site"),
//					pulumi.String("virtualization.cluster"),
//				},
//				ActionType:     pulumi.String("webhook"),
//				ActionObjectId: test.ID(),
//				EventTypes: pulumi.StringArray{
//					pulumi.String("object_created"),
//					pulumi.String("object_updated"),
//					pulumi.String("object_deleted"),
//					pulumi.String("job_started"),
//					pulumi.String("job_completed"),
//					pulumi.String("job_failed"),
//					pulumi.String("job_errored"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type EventRule struct {
	pulumi.CustomResourceState

	ActionObjectId pulumi.IntOutput `pulumi:"actionObjectId"`
	// Valid values are `webhook`.
	ActionType   pulumi.StringOutput      `pulumi:"actionType"`
	Conditions   pulumi.StringPtrOutput   `pulumi:"conditions"`
	ContentTypes pulumi.StringArrayOutput `pulumi:"contentTypes"`
	Description  pulumi.StringPtrOutput   `pulumi:"description"`
	// Defaults to `true`.
	Enabled pulumi.BoolPtrOutput `pulumi:"enabled"`
	// The types of event which will trigger this rule. By default, valid values are `objectCreated`, `ojectUpdated`, `objectDeleted`, `jobStarted`, `jobCompleted`, `jobFailed` and `jobErrored`.
	EventTypes pulumi.StringArrayOutput `pulumi:"eventTypes"`
	Name       pulumi.StringOutput      `pulumi:"name"`
	Tags       pulumi.StringArrayOutput `pulumi:"tags"`
	TagsAlls   pulumi.StringArrayOutput `pulumi:"tagsAlls"`
}

// NewEventRule registers a new resource with the given unique name, arguments, and options.
func NewEventRule(ctx *pulumi.Context,
	name string, args *EventRuleArgs, opts ...pulumi.ResourceOption) (*EventRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ActionObjectId == nil {
		return nil, errors.New("invalid value for required argument 'ActionObjectId'")
	}
	if args.ActionType == nil {
		return nil, errors.New("invalid value for required argument 'ActionType'")
	}
	if args.ContentTypes == nil {
		return nil, errors.New("invalid value for required argument 'ContentTypes'")
	}
	if args.EventTypes == nil {
		return nil, errors.New("invalid value for required argument 'EventTypes'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource EventRule
	err := ctx.RegisterResource("netbox:index/eventRule:EventRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetEventRule gets an existing EventRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetEventRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *EventRuleState, opts ...pulumi.ResourceOption) (*EventRule, error) {
	var resource EventRule
	err := ctx.ReadResource("netbox:index/eventRule:EventRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering EventRule resources.
type eventRuleState struct {
	ActionObjectId *int `pulumi:"actionObjectId"`
	// Valid values are `webhook`.
	ActionType   *string  `pulumi:"actionType"`
	Conditions   *string  `pulumi:"conditions"`
	ContentTypes []string `pulumi:"contentTypes"`
	Description  *string  `pulumi:"description"`
	// Defaults to `true`.
	Enabled *bool `pulumi:"enabled"`
	// The types of event which will trigger this rule. By default, valid values are `objectCreated`, `ojectUpdated`, `objectDeleted`, `jobStarted`, `jobCompleted`, `jobFailed` and `jobErrored`.
	EventTypes []string `pulumi:"eventTypes"`
	Name       *string  `pulumi:"name"`
	Tags       []string `pulumi:"tags"`
	TagsAlls   []string `pulumi:"tagsAlls"`
}

type EventRuleState struct {
	ActionObjectId pulumi.IntPtrInput
	// Valid values are `webhook`.
	ActionType   pulumi.StringPtrInput
	Conditions   pulumi.StringPtrInput
	ContentTypes pulumi.StringArrayInput
	Description  pulumi.StringPtrInput
	// Defaults to `true`.
	Enabled pulumi.BoolPtrInput
	// The types of event which will trigger this rule. By default, valid values are `objectCreated`, `ojectUpdated`, `objectDeleted`, `jobStarted`, `jobCompleted`, `jobFailed` and `jobErrored`.
	EventTypes pulumi.StringArrayInput
	Name       pulumi.StringPtrInput
	Tags       pulumi.StringArrayInput
	TagsAlls   pulumi.StringArrayInput
}

func (EventRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*eventRuleState)(nil)).Elem()
}

type eventRuleArgs struct {
	ActionObjectId int `pulumi:"actionObjectId"`
	// Valid values are `webhook`.
	ActionType   string   `pulumi:"actionType"`
	Conditions   *string  `pulumi:"conditions"`
	ContentTypes []string `pulumi:"contentTypes"`
	Description  *string  `pulumi:"description"`
	// Defaults to `true`.
	Enabled *bool `pulumi:"enabled"`
	// The types of event which will trigger this rule. By default, valid values are `objectCreated`, `ojectUpdated`, `objectDeleted`, `jobStarted`, `jobCompleted`, `jobFailed` and `jobErrored`.
	EventTypes []string `pulumi:"eventTypes"`
	Name       *string  `pulumi:"name"`
	Tags       []string `pulumi:"tags"`
}

// The set of arguments for constructing a EventRule resource.
type EventRuleArgs struct {
	ActionObjectId pulumi.IntInput
	// Valid values are `webhook`.
	ActionType   pulumi.StringInput
	Conditions   pulumi.StringPtrInput
	ContentTypes pulumi.StringArrayInput
	Description  pulumi.StringPtrInput
	// Defaults to `true`.
	Enabled pulumi.BoolPtrInput
	// The types of event which will trigger this rule. By default, valid values are `objectCreated`, `ojectUpdated`, `objectDeleted`, `jobStarted`, `jobCompleted`, `jobFailed` and `jobErrored`.
	EventTypes pulumi.StringArrayInput
	Name       pulumi.StringPtrInput
	Tags       pulumi.StringArrayInput
}

func (EventRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*eventRuleArgs)(nil)).Elem()
}

type EventRuleInput interface {
	pulumi.Input

	ToEventRuleOutput() EventRuleOutput
	ToEventRuleOutputWithContext(ctx context.Context) EventRuleOutput
}

func (*EventRule) ElementType() reflect.Type {
	return reflect.TypeOf((**EventRule)(nil)).Elem()
}

func (i *EventRule) ToEventRuleOutput() EventRuleOutput {
	return i.ToEventRuleOutputWithContext(context.Background())
}

func (i *EventRule) ToEventRuleOutputWithContext(ctx context.Context) EventRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EventRuleOutput)
}

// EventRuleArrayInput is an input type that accepts EventRuleArray and EventRuleArrayOutput values.
// You can construct a concrete instance of `EventRuleArrayInput` via:
//
//	EventRuleArray{ EventRuleArgs{...} }
type EventRuleArrayInput interface {
	pulumi.Input

	ToEventRuleArrayOutput() EventRuleArrayOutput
	ToEventRuleArrayOutputWithContext(context.Context) EventRuleArrayOutput
}

type EventRuleArray []EventRuleInput

func (EventRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*EventRule)(nil)).Elem()
}

func (i EventRuleArray) ToEventRuleArrayOutput() EventRuleArrayOutput {
	return i.ToEventRuleArrayOutputWithContext(context.Background())
}

func (i EventRuleArray) ToEventRuleArrayOutputWithContext(ctx context.Context) EventRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EventRuleArrayOutput)
}

// EventRuleMapInput is an input type that accepts EventRuleMap and EventRuleMapOutput values.
// You can construct a concrete instance of `EventRuleMapInput` via:
//
//	EventRuleMap{ "key": EventRuleArgs{...} }
type EventRuleMapInput interface {
	pulumi.Input

	ToEventRuleMapOutput() EventRuleMapOutput
	ToEventRuleMapOutputWithContext(context.Context) EventRuleMapOutput
}

type EventRuleMap map[string]EventRuleInput

func (EventRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*EventRule)(nil)).Elem()
}

func (i EventRuleMap) ToEventRuleMapOutput() EventRuleMapOutput {
	return i.ToEventRuleMapOutputWithContext(context.Background())
}

func (i EventRuleMap) ToEventRuleMapOutputWithContext(ctx context.Context) EventRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EventRuleMapOutput)
}

type EventRuleOutput struct{ *pulumi.OutputState }

func (EventRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EventRule)(nil)).Elem()
}

func (o EventRuleOutput) ToEventRuleOutput() EventRuleOutput {
	return o
}

func (o EventRuleOutput) ToEventRuleOutputWithContext(ctx context.Context) EventRuleOutput {
	return o
}

func (o EventRuleOutput) ActionObjectId() pulumi.IntOutput {
	return o.ApplyT(func(v *EventRule) pulumi.IntOutput { return v.ActionObjectId }).(pulumi.IntOutput)
}

// Valid values are `webhook`.
func (o EventRuleOutput) ActionType() pulumi.StringOutput {
	return o.ApplyT(func(v *EventRule) pulumi.StringOutput { return v.ActionType }).(pulumi.StringOutput)
}

func (o EventRuleOutput) Conditions() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EventRule) pulumi.StringPtrOutput { return v.Conditions }).(pulumi.StringPtrOutput)
}

func (o EventRuleOutput) ContentTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *EventRule) pulumi.StringArrayOutput { return v.ContentTypes }).(pulumi.StringArrayOutput)
}

func (o EventRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EventRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Defaults to `true`.
func (o EventRuleOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EventRule) pulumi.BoolPtrOutput { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// The types of event which will trigger this rule. By default, valid values are `objectCreated`, `ojectUpdated`, `objectDeleted`, `jobStarted`, `jobCompleted`, `jobFailed` and `jobErrored`.
func (o EventRuleOutput) EventTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *EventRule) pulumi.StringArrayOutput { return v.EventTypes }).(pulumi.StringArrayOutput)
}

func (o EventRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *EventRule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o EventRuleOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *EventRule) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

func (o EventRuleOutput) TagsAlls() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *EventRule) pulumi.StringArrayOutput { return v.TagsAlls }).(pulumi.StringArrayOutput)
}

type EventRuleArrayOutput struct{ *pulumi.OutputState }

func (EventRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*EventRule)(nil)).Elem()
}

func (o EventRuleArrayOutput) ToEventRuleArrayOutput() EventRuleArrayOutput {
	return o
}

func (o EventRuleArrayOutput) ToEventRuleArrayOutputWithContext(ctx context.Context) EventRuleArrayOutput {
	return o
}

func (o EventRuleArrayOutput) Index(i pulumi.IntInput) EventRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *EventRule {
		return vs[0].([]*EventRule)[vs[1].(int)]
	}).(EventRuleOutput)
}

type EventRuleMapOutput struct{ *pulumi.OutputState }

func (EventRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*EventRule)(nil)).Elem()
}

func (o EventRuleMapOutput) ToEventRuleMapOutput() EventRuleMapOutput {
	return o
}

func (o EventRuleMapOutput) ToEventRuleMapOutputWithContext(ctx context.Context) EventRuleMapOutput {
	return o
}

func (o EventRuleMapOutput) MapIndex(k pulumi.StringInput) EventRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *EventRule {
		return vs[0].(map[string]*EventRule)[vs[1].(string)]
	}).(EventRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*EventRuleInput)(nil)).Elem(), &EventRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*EventRuleArrayInput)(nil)).Elem(), EventRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*EventRuleMapInput)(nil)).Elem(), EventRuleMap{})
	pulumi.RegisterOutputType(EventRuleOutput{})
	pulumi.RegisterOutputType(EventRuleArrayOutput{})
	pulumi.RegisterOutputType(EventRuleMapOutput{})
}
