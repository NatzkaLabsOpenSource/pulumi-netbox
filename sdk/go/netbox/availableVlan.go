// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package netbox

import (
	"context"
	"reflect"

	"github.com/NatzkaLabsOpenSource/pulumi-netbox/sdk/go/netbox/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Per [the docs](https://netbox.readthedocs.io/en/stable/models/ipam/vlan/):
//
// > A VLAN represents an isolated Layer 2 domain identified by a numeric ID (1â€“4094). VLANs may be assigned to specific sites or marked as global.
// Optionally, they can be organized within VLAN groups to define scope and enforce uniqueness.
// >
// > Each VLAN can also be assigned an operational status and a functional role. Statuses are hard-coded in NetBox and include the following:
// > * Active
// > * Reserved
// > * Deprecated
//
// This resource will retrieve the next available VLAN ID from a given VLAN group (specified by ID).
type AvailableVlan struct {
	pulumi.CustomResourceState

	Comments    pulumi.StringOutput      `pulumi:"comments"`
	Description pulumi.StringPtrOutput   `pulumi:"description"`
	GroupId     pulumi.IntPtrOutput      `pulumi:"groupId"`
	Name        pulumi.StringOutput      `pulumi:"name"`
	RoleId      pulumi.IntPtrOutput      `pulumi:"roleId"`
	SiteId      pulumi.IntPtrOutput      `pulumi:"siteId"`
	Status      pulumi.StringPtrOutput   `pulumi:"status"`
	Tags        pulumi.StringArrayOutput `pulumi:"tags"`
	TagsAlls    pulumi.StringArrayOutput `pulumi:"tagsAlls"`
	TenantId    pulumi.IntPtrOutput      `pulumi:"tenantId"`
	Vid         pulumi.IntOutput         `pulumi:"vid"`
}

// NewAvailableVlan registers a new resource with the given unique name, arguments, and options.
func NewAvailableVlan(ctx *pulumi.Context,
	name string, args *AvailableVlanArgs, opts ...pulumi.ResourceOption) (*AvailableVlan, error) {
	if args == nil {
		args = &AvailableVlanArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AvailableVlan
	err := ctx.RegisterResource("netbox:index/availableVlan:AvailableVlan", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAvailableVlan gets an existing AvailableVlan resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAvailableVlan(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AvailableVlanState, opts ...pulumi.ResourceOption) (*AvailableVlan, error) {
	var resource AvailableVlan
	err := ctx.ReadResource("netbox:index/availableVlan:AvailableVlan", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AvailableVlan resources.
type availableVlanState struct {
	Comments    *string  `pulumi:"comments"`
	Description *string  `pulumi:"description"`
	GroupId     *int     `pulumi:"groupId"`
	Name        *string  `pulumi:"name"`
	RoleId      *int     `pulumi:"roleId"`
	SiteId      *int     `pulumi:"siteId"`
	Status      *string  `pulumi:"status"`
	Tags        []string `pulumi:"tags"`
	TagsAlls    []string `pulumi:"tagsAlls"`
	TenantId    *int     `pulumi:"tenantId"`
	Vid         *int     `pulumi:"vid"`
}

type AvailableVlanState struct {
	Comments    pulumi.StringPtrInput
	Description pulumi.StringPtrInput
	GroupId     pulumi.IntPtrInput
	Name        pulumi.StringPtrInput
	RoleId      pulumi.IntPtrInput
	SiteId      pulumi.IntPtrInput
	Status      pulumi.StringPtrInput
	Tags        pulumi.StringArrayInput
	TagsAlls    pulumi.StringArrayInput
	TenantId    pulumi.IntPtrInput
	Vid         pulumi.IntPtrInput
}

func (AvailableVlanState) ElementType() reflect.Type {
	return reflect.TypeOf((*availableVlanState)(nil)).Elem()
}

type availableVlanArgs struct {
	Description *string  `pulumi:"description"`
	GroupId     *int     `pulumi:"groupId"`
	Name        *string  `pulumi:"name"`
	RoleId      *int     `pulumi:"roleId"`
	SiteId      *int     `pulumi:"siteId"`
	Status      *string  `pulumi:"status"`
	Tags        []string `pulumi:"tags"`
	TenantId    *int     `pulumi:"tenantId"`
}

// The set of arguments for constructing a AvailableVlan resource.
type AvailableVlanArgs struct {
	Description pulumi.StringPtrInput
	GroupId     pulumi.IntPtrInput
	Name        pulumi.StringPtrInput
	RoleId      pulumi.IntPtrInput
	SiteId      pulumi.IntPtrInput
	Status      pulumi.StringPtrInput
	Tags        pulumi.StringArrayInput
	TenantId    pulumi.IntPtrInput
}

func (AvailableVlanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*availableVlanArgs)(nil)).Elem()
}

type AvailableVlanInput interface {
	pulumi.Input

	ToAvailableVlanOutput() AvailableVlanOutput
	ToAvailableVlanOutputWithContext(ctx context.Context) AvailableVlanOutput
}

func (*AvailableVlan) ElementType() reflect.Type {
	return reflect.TypeOf((**AvailableVlan)(nil)).Elem()
}

func (i *AvailableVlan) ToAvailableVlanOutput() AvailableVlanOutput {
	return i.ToAvailableVlanOutputWithContext(context.Background())
}

func (i *AvailableVlan) ToAvailableVlanOutputWithContext(ctx context.Context) AvailableVlanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailableVlanOutput)
}

// AvailableVlanArrayInput is an input type that accepts AvailableVlanArray and AvailableVlanArrayOutput values.
// You can construct a concrete instance of `AvailableVlanArrayInput` via:
//
//	AvailableVlanArray{ AvailableVlanArgs{...} }
type AvailableVlanArrayInput interface {
	pulumi.Input

	ToAvailableVlanArrayOutput() AvailableVlanArrayOutput
	ToAvailableVlanArrayOutputWithContext(context.Context) AvailableVlanArrayOutput
}

type AvailableVlanArray []AvailableVlanInput

func (AvailableVlanArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AvailableVlan)(nil)).Elem()
}

func (i AvailableVlanArray) ToAvailableVlanArrayOutput() AvailableVlanArrayOutput {
	return i.ToAvailableVlanArrayOutputWithContext(context.Background())
}

func (i AvailableVlanArray) ToAvailableVlanArrayOutputWithContext(ctx context.Context) AvailableVlanArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailableVlanArrayOutput)
}

// AvailableVlanMapInput is an input type that accepts AvailableVlanMap and AvailableVlanMapOutput values.
// You can construct a concrete instance of `AvailableVlanMapInput` via:
//
//	AvailableVlanMap{ "key": AvailableVlanArgs{...} }
type AvailableVlanMapInput interface {
	pulumi.Input

	ToAvailableVlanMapOutput() AvailableVlanMapOutput
	ToAvailableVlanMapOutputWithContext(context.Context) AvailableVlanMapOutput
}

type AvailableVlanMap map[string]AvailableVlanInput

func (AvailableVlanMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AvailableVlan)(nil)).Elem()
}

func (i AvailableVlanMap) ToAvailableVlanMapOutput() AvailableVlanMapOutput {
	return i.ToAvailableVlanMapOutputWithContext(context.Background())
}

func (i AvailableVlanMap) ToAvailableVlanMapOutputWithContext(ctx context.Context) AvailableVlanMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailableVlanMapOutput)
}

type AvailableVlanOutput struct{ *pulumi.OutputState }

func (AvailableVlanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AvailableVlan)(nil)).Elem()
}

func (o AvailableVlanOutput) ToAvailableVlanOutput() AvailableVlanOutput {
	return o
}

func (o AvailableVlanOutput) ToAvailableVlanOutputWithContext(ctx context.Context) AvailableVlanOutput {
	return o
}

func (o AvailableVlanOutput) Comments() pulumi.StringOutput {
	return o.ApplyT(func(v *AvailableVlan) pulumi.StringOutput { return v.Comments }).(pulumi.StringOutput)
}

func (o AvailableVlanOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AvailableVlan) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o AvailableVlanOutput) GroupId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AvailableVlan) pulumi.IntPtrOutput { return v.GroupId }).(pulumi.IntPtrOutput)
}

func (o AvailableVlanOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *AvailableVlan) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o AvailableVlanOutput) RoleId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AvailableVlan) pulumi.IntPtrOutput { return v.RoleId }).(pulumi.IntPtrOutput)
}

func (o AvailableVlanOutput) SiteId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AvailableVlan) pulumi.IntPtrOutput { return v.SiteId }).(pulumi.IntPtrOutput)
}

func (o AvailableVlanOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AvailableVlan) pulumi.StringPtrOutput { return v.Status }).(pulumi.StringPtrOutput)
}

func (o AvailableVlanOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AvailableVlan) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

func (o AvailableVlanOutput) TagsAlls() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AvailableVlan) pulumi.StringArrayOutput { return v.TagsAlls }).(pulumi.StringArrayOutput)
}

func (o AvailableVlanOutput) TenantId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AvailableVlan) pulumi.IntPtrOutput { return v.TenantId }).(pulumi.IntPtrOutput)
}

func (o AvailableVlanOutput) Vid() pulumi.IntOutput {
	return o.ApplyT(func(v *AvailableVlan) pulumi.IntOutput { return v.Vid }).(pulumi.IntOutput)
}

type AvailableVlanArrayOutput struct{ *pulumi.OutputState }

func (AvailableVlanArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AvailableVlan)(nil)).Elem()
}

func (o AvailableVlanArrayOutput) ToAvailableVlanArrayOutput() AvailableVlanArrayOutput {
	return o
}

func (o AvailableVlanArrayOutput) ToAvailableVlanArrayOutputWithContext(ctx context.Context) AvailableVlanArrayOutput {
	return o
}

func (o AvailableVlanArrayOutput) Index(i pulumi.IntInput) AvailableVlanOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AvailableVlan {
		return vs[0].([]*AvailableVlan)[vs[1].(int)]
	}).(AvailableVlanOutput)
}

type AvailableVlanMapOutput struct{ *pulumi.OutputState }

func (AvailableVlanMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AvailableVlan)(nil)).Elem()
}

func (o AvailableVlanMapOutput) ToAvailableVlanMapOutput() AvailableVlanMapOutput {
	return o
}

func (o AvailableVlanMapOutput) ToAvailableVlanMapOutputWithContext(ctx context.Context) AvailableVlanMapOutput {
	return o
}

func (o AvailableVlanMapOutput) MapIndex(k pulumi.StringInput) AvailableVlanOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AvailableVlan {
		return vs[0].(map[string]*AvailableVlan)[vs[1].(string)]
	}).(AvailableVlanOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AvailableVlanInput)(nil)).Elem(), &AvailableVlan{})
	pulumi.RegisterInputType(reflect.TypeOf((*AvailableVlanArrayInput)(nil)).Elem(), AvailableVlanArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AvailableVlanMapInput)(nil)).Elem(), AvailableVlanMap{})
	pulumi.RegisterOutputType(AvailableVlanOutput{})
	pulumi.RegisterOutputType(AvailableVlanArrayOutput{})
	pulumi.RegisterOutputType(AvailableVlanMapOutput{})
}
